https://pep8-ja.readthedocs.io/ja/latest/
> _single_leading_underscore: "内部でだけ使う" ことを示します。 たとえば from M import * は、アンダースコアで始まる名前のオブジェクトをimportしません。


> single_trailing_underscore_: Python のキーワードと衝突するのを避けるために使われる規約です。例を以下に挙げます:
> 
> tkinter.Toplevel(master, class_='ClassName')
> __double_leading_underscore: クラスの属性に名前を付けるときに、名前のマングリング機構を呼び出します (クラス Foobar の __boo という名前は _FooBar__boo になります。以下も参照してください)


> 型変数の名前
> PEP 484 で導入された型変数の名前には、通常 CapWords 方式を使うべきです。また、 T や AnyStr や Num のような短い名前が好ましいです。 共変や反変の振る舞いをする変数を宣言するために _co や _contra のような名前を変数の末尾に付け加えることを推奨します:
> 
> from typing import TypeVar
> 
> VT_co = TypeVar('VT_co', covariant=True)
> KT_contra = TypeVar('KT_contra', contravariant=True)


> Python はアンダースコアが先頭に二つ付いた名前にクラス名を追加します。つまり、クラス Foo に __a という名前の属性があった場合、この名前は Foo.__a ではアクセスできません (どうしてもアクセスしたいユーザーは Foo._Foo__a とすればアクセスできます)。


> サブクラス化して使うクラスがあるとします。サブクラスで使って欲しくない属性があった場合、その名前の最後ではなく、先頭にアンダースコアを二つ付けることを検討してみましょう。これによって Python のマングリングアルゴリズムが呼び出され、その属性にはクラス名が付加されます。これはサブクラスにうっかり同名の属性が入ってしまうことによる属性の衝突を避けるのに役立ちます。

> 注意1: マングリングされる名前は、単なるクラス名であることに注意して下さい。よって、サブクラスで親クラスと同じ名前のクラス名と属性名を選んだ場合、衝突は回避できません。

> 注意2: 名前のマングリングは、ユースケースによっては不便な場合もあります。たとえば __getattr__() を使ったり、デバッグを行う場合です。しかし、名前のマングリングアルゴリズムはきちんとドキュメント化されているので、簡単に手動で実行できます。

> 注意3: 皆がマングリングを好きだとは限りません。うっかり名前を衝突させてしまうリスクを避けることと、Pythonの上級者が使う可能性があることとのバランスを考えましょう。

https://www.ibm.com/docs/ja/i/7.3?topic=linkage-name-mangling-c-only
> 名前マングリングは、 関数名および変数名を固有の名前にエンコードして、 リンカーが言語内の共通名を分離できるようにすることです。また、型名もマングルできます。 名前マングリングは、多重定義フィーチャーの機能性および異なるスコープ内での可視性を向上させるために、 一般的に使用されています。 モジュールをコンパイルする場合、コンパイラーは関数引数の型をエンコードして、関数名を生成します。


> return文は一貫した書き方をしましょう。関数の中の全てのreturn文は式を返すか、全く何も返さないかのどちらかにすべきです。式を返しているreturn文が関数の中にある場合、値を何も返さないreturn文は 明示的に return None と書くべきですし、(到達可能であれば)return文を関数の最後に明示的に置くべきです。:
